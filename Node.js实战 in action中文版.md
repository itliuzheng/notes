# 关于本书

本书的主要目的是教你学会如何创建和部署Node 程序，重点是Web程序。

本书中有相当一部分内容集中介绍了Web 程序框架Express和中间件框架Connect ，主要是因为它们的用途和社区的支持。你还会学到如何创建自动化测试，以及如何部署你的程序。
本书面向希望用Node 扣创建响应式、可伸缩程序的有经验的Web程序开发人员。因为Node.js 程序是用JavaScript写的，所以需要你掌握这门语言。此外最好还要熟悉Windows 、OS X或Linux命令行。

1. 第一部分介绍了Node.js ，教授了一些用它做开发所需要的基础技术。

   第l 章阐述了Node 的特征，并给出了一些示例代码。

   第2章指导读者创建了一个示例程序。

   第3章阐述了Node.js开发的困难之处，以及可以用来克服这些困难的技术，并给出了组织程序代码的办法。

2. 第二部分在本书中所占比重最大，主要讨论Web程序开发。

   第4章讲了基于Node创建Web程序的基础知识，、

   第5 章讨论了如何用Node存储程序数据。
   然后第二部分继续深入Web相关框架。

   第6章介绍TConnect框架，阐述了它的好处和它的工作机制。

   第7章讲述了Connect框架内置的各种组件，以及如何用它们给Web程序添加功能。

   第8章介绍了Express框架。

   第9 章指导读者体验Express 的高级用法。涵盖了Web开发的基础知识后，

   第二部分又探索了两个相关的主题。

   第10章指导读者使用各种Node测试框架，

   第11 章讲了在Node Web程序中如何用模板将数据展示从逻辑中分离出来。

3. 第三部分转而讨论了可以用Node完成的Web开发之外的事’情。

   第12 章讨论了如何把Node程序部署到生产服务器上、如何维护在线时间，以及如何将性能提升到最优。

   第13章阐述了如何创建非HTTP程序，如何用Socket.io框架创建实时程序，以及如f可使用一些便利的Node 内置API。

   第14章讨论了Node社区的工作机制，以及如何用Node包管理器发布Node作品。

## 第1章 欢迎进入Node.js 世界



### 构建于JavaScript之上

在服务器端编程， Node使用的是为Google Chrome提供动力的v8虚拟机。V8让Node在性能上得到了巨大的提升，因为它去掉了中间环节，执行的不是字节码，用的也不是解释器，而是直接编译成了本地机器码

好处：

	1.	开发人员用一种语言就能编写整个Web应用，这可以减少开发客户端和服务端时所需的语言切换。这样代码可以在客户端和服务端中共享，比如在表单校验或游戏逻辑中使用同样一段代码。
	2.	JSON是目前非常流行的数据交换格式，并且还是JavaScript原生的。
	3.	有些NoSQL数据库中用的就是JavaScript语言（ 比如CouchDB 和MongoDB ），所以跟它们简直是天作之合（比如MongoDB 的管理和查询语言都是JavaScript; CouchDB 的map/reduce也是JavaScript ）。
	4.	JavaScript是一门编译目标语言，现在有很多可以编译成JavaScript的语言
	5.	Node 用的虚拟机(v8)会紧跟ECMAScript标准。换句话说，在Node 中如果想用新的
	 JavaScripti吾言特性，不用等到所有浏览器都支持

### 异步和事件触发：浏览器

Node为服务端JavaScript提供了一个事件驱动的、异步的平台。它把JavaScript带到服务端中
的方式跟浏览器把JavaScript带到客户端的方式几乎一模一样。了解浏览器的工作原理对我们了解Node 的工作原理会有很大帮助。

它们都是事件驱动（用事件轮询）和非阻塞的I/O处理（用异步I/0 ）



### 异步和事件触发：服务器

可能大多数人都了解传统的服务端编程的I/O模型，下面是一个PHP的例子：

```php
$result = mysql_query ('SELECT* FROM myTable'); 
print_r($result)
//在数据库查询完成之前程序！ 不会继续执行
```

这段代码做了些I/O操作，并且在所有数据回来之前，这个进程会被阻塞。

对于很多程序而言，这个模型没什么问题，并且很容易理解。

但有一点可能会被忽略：这个进程也有状态，或者说内存空间，并且在I/O完成之前基本上什么也不会做。根据I/O操作的延迟情况，那可能会有10ms到几分钟的时间。延迟也可能是由下列意外情况引发的：

 	1. 硬盘正在执行维护操作， 读／写都暂停了；
 	2. 因为负载增加，数据库查询变得更慢了；
 	3. 由于某种原因，今天从 某个地方xxx 拉取资源非常迟缓。

如果程序在I/O上阻塞了，当有更多请求过来时，服务器会怎么处理呢？在这种情景中通常会用多线程的方式。

一种常见的实现是给每个连接分配一个线程，并为那些连接设置一个线程池。你可以把线程想象成一个计算工作区，处理器在这个工作区中完成指定的任务。

线程通常都是处于进程之内的，并且会维护它自己的工作内存。每个线程会处理一到多个服务器连接。尽管这听起来是个很自然的委派服务器劳动力的方式（最起码对那些曾经长期采用这种方式的开发人员来说是这样的），但程序内的线程管理会非常复杂。此外， 当需要大量的线程处理很多并发的服务器连接时，线程会消耗额外的操作系统资源。线程需要CPU和额外的RAM来做上下文切换。
为了说明这一点，我们来看NGINX 和Apache 的一个基准比较（见图1-2 ，源自http://mng.bz/eaZT ）。或许你还不了解NGINX (http://nginx.com/ ），它跟Apache 一样，是个HTTP 服务器，但它用的不是带有阻塞1/0 的多线程方式，而是带有异步1/0 的事件轮询（就像浏览器和lNode 一样）。因为这些设计上的选择， NGINX通常能处理更多的请求和客户端连接，它因此变成了响应能力更强的解决方案。

```shell
#连接数为3500时， NGINX 的请求处理速度几乎要快 Apache 三倍
```

在Node中， I/O几乎总是在主事件轮询之外进行，使得服务器可以一直处于高效并且随时能
够做出响应的状态，就像NGINX一样。这样进程就更加不会受I/O 限制，因为I/O延迟不会拖垮服
务器，或者像在阻塞方式下那样占用很多资源。因此一些在服务器上曾经是重量级的操作，在
Node服务器上仍然可以是轻量级的。这个混杂了事件驱动和异步的模型，加上几乎随处可用的JavaScripti吾言，帮我们打开了一个精彩纷呈的数据密集型实时程序的世界。

### DIRT程序 (data-intensive real-time)   数据密集型实时程序

实际上， Node 所针对的应用程序有一个专门的简称： DIRT 。它表示数据密集型实时(data-intensive real-time)程序。因为Node 自身在I/O上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。

对Web来说，实时程序是个新生事物。现在有很多Web程序提供的信息几乎都是即时的，比如通过

白板在线协作、

对临近公交车的实时精确定位，

以及多人在线游戏。

不管是用实时组件增强已有程序，还是打造全新的程序， Web都在朝着响应性和协作型环境逐渐进发。而这种新型的Web应用程序需要一个能够实时响应大量并发用户请求的平台来支撑它们。这正是Node所擅长的领域，并且不仅限于Web程序，其他I/O 负载比较重的程序也可以用到它。
Browserling (browserling.com)就是一个用Node开发的DIRT程序，它是一个很好的范例。在这个网站上，我们可以在浏览器中使用各种浏览器。这对Web前端开发工程师来说特别有用，因为他们再也不用仅仅为了测试就去装一堆的浏览器和操作系统了。Browserling 用了一个叫做StackVM 的由Node 驱动的项目，而StackVM管理了用QEMU （快速模拟器）模拟器创建的虚拟机， QEMU会模拟运行浏览器所需的CPU和外设。

Browserling在VM 中运行测试浏览器，将键盘和鼠标的输入数据从用户的浏览器中转到模拟出来的浏览器中，然后将模拟浏览器中要重新渲染的区域转出来，在用户浏览器的画布上重新画出来。图1-4 向我们呈现了这一过程。
Browserling还有一个使用Node 的互补项目Testling ( testling.com ），它可以通过命令行在多个
浏览器上井行运行测试包。
Browserling和Testling都是很好的DIRT程序范例，并且构建像它们这样可伸缩的网络程序所用的基础设施在你坐下来写第一个Node程序时就在发挥作用了。我们来看看Node的API是如何提供这些开箱即用的工具的。

![image-20201027113034485](C:\Users\zdwljs\AppData\Roaming\Typora\typora-user-images\image-20201027113034485.png)

### 默认DIRT

Node从构建开始就有一个事件驱动和异步的模型。JavaScript从来没有过标准的I/O 库，那是服务端语言的常见配置。对于JavaScript而言，这总是由“宿主”环境决定的。JavaScript 最常见的宿主环境，也是大多数开发人员所用的，就是浏览器，它是事件驱动和异步的。Node重新实现了宿主中那些常用的对象，尽量让浏览器和服务器保持一致，比如：

	1. 计时器API （比如setTimeout );
	2. 控制台API （比如console.log）

Node还有一组用来处理多种网络和文件I/O的核心模块。其中包括用于HTTP 、TLS 、HTTPS 、文件系统（POSIX）、数据报（ UDP ）和NET (TCP)的模块。这些核心模块刻意做得很小、底层并且简单，只包含要给基于I/O的程序用的组成部分。第三方模块基于这些核心模块，针对常见的问题进行了更高层的抽象。

```SHELL
#平台与框架
##Node 是JavaScript程序的平台，不要把它跟框架相混淆。很多人都误把Node 当做JavaScript上的Rails或Djaogo ，实际上它更底层。
##但如果你对Web程序的框架感兴趣，本书后面会介绍在Node 中非常流行的Express框架。

```

聊了这么多了，你可能很想知道Node程序的代码长什么样子。我们来看几个简单的例子：

	1. 一个简单的异步程序；
	2. 一个Hello World Web服务器；
	3. 一个数据流的例子。

#### 简单的异步程序

```javascript
var fs = require('fs');
fs.readFile('./resource.json',function(err,data){
    console.log(data);
})
```

这段程序要从硬盘里读取resource. json文件。当所有数据都读出来后，会调用那个匿名函数（即“回调函数”），传给它的参数是err （如果出现错误）和data （文件中的数据）。

这个过程是在后台完成的，这样在该过程中，我们可以继续处理其他任何操作，直到数据准备好。我们之前说过的那些事件触发和异步的好处都是自动实现的。差别在于，这个不是在浏览器中用jQuery发起一个Ajax请求，而是在Node 中访问文件系统抓取resource.json 。后面这个过程如图1-5 所示

![image-20201027113900248](C:\Users\zdwljs\AppData\Roaming\Typora\typora-user-images\image-20201027113900248.png)

#### Hello World HTTP服务器

#### 流数据

### 小结



## 第2章 构建有多个房间的聊天室程序



### 程序概览

本章会构建一个在线聊天程序，

	1. 用户可以在一个简单的表单中输入消息，相互聊天，消息输入后会发送给同一个聊天室内的其他所有用户。
	2. 进入聊天室后，程序会自动给用户分配一个昵称，但他们可以用聊天命令修改自己的昵称，聊天命令以斜杠（／）开头。
	3. 同样，用户也可以输入命令创建新的聊天室（或加入已有的聊天室），在加入或创建聊天室时，新聊天室的名称会出现在聊天程序顶端的水平条上，也会出现在聊天消息区域右侧的可用房间列表中。
	4. 在用户换到新房间后，系统会确认这一变化。

虽然从功能上看这个程序充其量只能算一个准系统，但它已经可以展示构建实时Web程序所需的重要组件和基本技术了。这个程序表明了Node如何同时处理传统的HTTP数据（比如静态文件）和实时数据（聊天消息）。通过它还能看出Node程序是如何组织的，以及依赖项是如何管理的。

### 程序需求及初始设置

将要创建的聊天程序需要完成如下任务：

	1. 提供静态文件（比如HT沁旦、css和客户端JavaScript);
	2. 在服务器上处理与聊天相关的消息；
	3. 在用户的浏览器中处理与聊天相关的消息。

   为了提供静态文件，需要使用Node内置的http模块。但通过HTTP提供文件时，通常不能只是发送文件中的内容，还应该有 所发送文件的类型。也就是说要用正确的MIME类型设置HTTP头的Content-Type 。为了查找这些MIME类型，你会用到第三方的模块mime 。

​	**MIME类型 **  在维基百科上的文章 http://en.wikipedia.org/wiki/MIME 中有详细论述。

​	为了处理与聊天相关的消息，需要用Ajax轮询服务器。但为了让这个程序能尽可能快地做出响应，我们不会用传统的Ajax发送消息。Ajax用HTTP作为传输机制，并且HTTP本来就不是做实时通信的。在用HTTP发送消息时，必须用一个新的TCP/IP连接。打开和关闭连接需要时间。此外，因为每次请求都要发送HTTP 头，所以传输的数据量也比较大。这个程序没用依赖于HTTP的方案，而是采用了WebSocket (http://en.wikipedia.org/wiki/WebSocket)，这是一个为支持实时通讯而设计的轻量的双向通信协议。
​	因为在大多数情况下，只有兼容HTML5 的浏览器才支持Web Socket ，所以这个程序会使用流行的Socket.IO库（ http://socket.io/），它给不能使用WebSocket的浏览器提供了一些后备措施，包括使用Flash 。Socket.IO 对后备功能的处理是透明的，不需要额外的代码或配置。第13 章对Socket.IO做了更深入的介绍。在开始做程序的文件结构和依赖项设置这些真正的初期工作之前，我们先聊聊Node如何同时处理HTTP和WebSocket ，

_**这是选它做实时程序最好的理由之一。**_

#### 提供HTTP 和WebSocket服务

尽管这个程序不会用Ajax发送和接收聊天消息，但它仍要用HTTP发送用在用户浏览器中的HTML 、css和客户端JavaScript 。

如图2-5 所示， Node用一个端口就可以轻松地提供HTTP 和WebSocket两种服务。Node带有一个可以提供HTTP服务功能的模块。还有一些第三方的Node模块，比如构建在Node 内置功能上的Express ，它让Web服务变得更加容易了。我们将在第8章深入探讨如何用Express构建Web程序。然而在本章的程序中，还是以介绍基础知识为主。

![image-20201027143102482](C:\Users\zdwljs\AppData\Roaming\Typora\typora-user-images\image-20201027143102482.png)

现在你对程序要用的核心技术已经有了大概的认识，让我们把它充实起

#### 创建程序的文件结构



#### 指明依赖项
#### 安装依赖项

### 提供HTML 、css 和客户端JavaScript的服务

#### 创建静态文件服务器
#### 添加HTML 和css 文件
### 用Socket.IO 处理与聊天相关的消息
#### 设置Socket.IO 服务器
#### 处理程序场景及事件
### 在程序的用户界面上使用客户端JavaScript



# 11 Web程序模板

模板雏形

```javascript
let html = ``
//手动分割字符串
let result = html.split('---')

let arr = result.map(item => {
	let lines = item.split('\n');
	let json = {};
	lines.map(list => {
		if (list.indexOf('Description：') != -1) {
			json.description = list.replace(/Description：/, '')
		} else if (list.indexOf('Keywords：') != -1) {
			json.keywords = list.replace('Keywords：', '')
		} else if (list.length) {
			json.title = list;
		}
	})
	return json
})

const fs = require("fs");
fs.writeFileSync('./xxx.js', JSON.stringify(arr))
```



## 11.2 嵌入JavaScript的模板



### 11.2.1 创建EJS模板

​	

### 11.2.2 用EJ过滤器提供常用的、与展示相关的功能、比如文本处理、排序和循环

### 11.2.3 在你的Node程序中集成EJS

### 11.2.4 把EJS用在客户端程序中



